#pragma config(Sensor, S1,     HTEOPD,              sensorAnalogActive)
#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivers/hitechnic-eopd.h"
#include "inparkeren.h"
#include "motors.h"

task main(){

}

void setMaxSpeed(int maxSpeed){
	//  if you want to achieve consistent speeds across battery level you must either not specify speeds above the 75% level or reduce the maximum speed level.
	nMaxRegulatedSpeedNxt = maxSpeed;
}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

// to see what happens
void displayProcessed(){
	nxtDisplayTextLine(3, "processed: %d", HTEOPDreadProcessed(HTEOPD));
}

// to see what happens
void displayRaw(){
	nxtDisplayTextLine(2, "raw: %d", HTEOPDreadRaw(HTEOPD));
}

void findEmptySpot(short maxSpeed, char speed){
	// read favourable position. not sure if raw or processed is better, but let's go with raw, because I only want to know if htere's something or not.
	int searchVal = HTEOPDreadRaw(HTEOPD);
	setMaxSpeed(maxSpeed);
	while ((HTEOPDreadRaw(HTEOPD) > (HTEOPDreadRaw(HTEOPD) - 500))
		&& (HTEOPDreadRaw(HTEOPD) < HTEOPDreadRaw(HTEOPD) + 500)){ // 'natte vinger' bounderies, find solid ones.
		move(speed); // keep looking until you find an empty spot
	}
	// empty spot found. Now do what you want to do once it's found. 
	// check if the hole is big enough

	// some other things?
	prioToInparkeren('Y');
}

/*
	automatic can be one of the following values: ['Y', 'N']
*/
void prioToInparkeren(char automatic){ 

}