#pragma config(Sensor, S2,     HTEOPD,              sensorAnalogActive)
#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivers/hitechnic-eopd.h"
#include "inparkeren.h"
#include "motors.h"

#define PI 3.1415
#define TAU 2*PI // is this fine?
// no processed because I don't need to be that accurate
#define kScale 7/0.63906 // 7 because cm
#define kError   12.0

task main(){
	inparkeren(750, 50, 2.8, 30);
}

// old friends
void setMaxSpeed(int maxSpeed){
	//  if you want to achieve consistent speeds across battery level you must either not specify speeds above the 75% level or reduce the maximum speed level.
	nMaxRegulatedSpeedNxt = maxSpeed;
}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

void resetEncAndSpecEncTarg(short target, char motorChar){
	switch (motorChar){
	case 'A':
		nMotorEncoder[motorA] = 0;
		nMotorEncoderTarget[motorA] = target;
		break;
	case 'B':
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = target;
		break;
	case 'C':
		nMotorEncoder[motorC] = 0;
		nMotorEncoderTarget[motorC] = target;
		break;
	}
}

void slaveMotor(char emperor, char slave){
	switch (emperor){
	case 'A':
		if (slave == 'B'){
			nSyncedMotors = synchAB;
			break;
		}
		else {
			break;
		}
	case 'B':
		if (slave == 'A'){
			nSyncedMotors = synchBA;
			break;
		}
		else{
			break;
		}
	}
}

// new stuff
// to see what happens
void displayProcessed(){
	nxtDisplayTextLine(3, "processed: %d", HTEOPDreadProcessed(HTEOPD));
}

// to see what happens
void displayRaw(){
	nxtDisplayTextLine(2, "raw: %d", HTEOPDreadRaw(HTEOPD));
}

void inparkeren(short maxSpeed, char speed, double radius/*or float*/, short minParkWidth){
	// read current object distance. not sure if raw or processed is better, but let's go with raw, because I only want to know if htere's something or not.
	int searchVal = HTEOPDreadRaw(HTEOPD);
	findEmptySpot(maxSpeed, speed, searchVal);
	wait10Msec(10);
	// empty spot found. Now do what you want to do once it's found. Measure 2nd searchval.
	int holeSearchVal = HTEOPDreadRaw(HTEOPD); // sensorValue for the hole.
	// check if the hole is big enough
	bool canPark = measureHole(maxSpeed, speed, holeSearchVal, radius, minParkWidth);
	wait10Msec(10);
	if (canPark){
		// de sensor bevindt zich nu als het goed is nog voor het gat.
		prioToInparkeren('Y', maxSpeed, speed, radius, 17, 0.24, searchVal);
		// parkeerfunctie
	} else {
		// nothing to be done so function stops. Or we can do some stuff but atm not necessary.
	}
}

double degreeTimes(short distance, double radius /*or float*/){
	double n = (distance / (TAU*radius));
	return n;
}
bool measureHole(short maxSpeed, char speed, int holeSearchVal, double radius, short minParkWidth){
	double degreeTimesVal = degreeTimes(minParkWidth, radius); // take minparkwidth ruim.
	double degrees = 360 * degreeTimesVal;
	short degreeTarget = (short)ceil(degrees); // ceil expects a float though, we can typecast and perhaps truncate. But look into the units of measurement I'll be using and check if this causes any problems to begin with.
	resetEncAndSpecEncTarg(degreeTarget, 'A');
	move(speed);
	while (abs(nMotorEncoder[motorA]) < degreeTarget){
		nxtDisplayTextLine(1, "target %d", degreeTarget);
		nxtDisplayTextLine(2, "enco %d", nMotorEncoder[motorA]);
		nxtDisplayTextLine(3, "sensoe %d", HTEOPDreadRaw(HTEOPD));
		if ((HTEOPDreadRaw(HTEOPD) > (holeSearchVal + 50))){ // same crap boundaries.
			//PlaySound(soundBeepBeep);
		move(0);
		nxtDisplayTextLine(5, "false");
		wait1Msec(1000);
			return false; // well not big enough.
		}
	}
	move(0);
	//PlaySound(soundException);
	nxtDisplayTextLine(5, "true");
		wait1Msec(1000);
	return true; // park place found.
}

void findEmptySpot(short maxSpeed, char speed, int searchVal){
	setMaxSpeed(maxSpeed);
	while (true){ // 'natte vinger' bounderies, find solid ones.
		nxtDisplayTextLine(3, "sensor %d", HTEOPDreadRaw(HTEOPD));
		nxtDisplayTextLine(2, "seachval %d", searchVal);
		wait10Msec(1);
		if(!(HTEOPDreadRaw(HTEOPD) > (searchVal - 50))){
			break;
			}
		move(speed); // keep looking until you find an empty spot
	}
	// empty spot found, now stop moving.
	move(0);
}

double getDistanceFromCircle(double radius, double turnTimes){
	double circumfence = TAU*radius;
	double distance = circumfence * turnTimes;
	return distance;
	}

short getTargetFromDistance(double distance, double radius){
	double degreeTimesVal = degreeTimes(distance, radius);
	double degrees = 360 * degreeTimesVal;
	short degreeTarget = (short)ceil(degrees);
	return degreeTarget;
	}

void park(short maxSpeed, char speed, double radiusWheel, double radiusBetweenWheels, double turnTimes, int sensorValFromEdge){
	setMaxSpeed(maxSpeed);
	// move backwards a bit due protruded sensors at the wheel
		short targetMoveBack = getTargetFromDistance(8, radiusWheel);
		resetEncAndSpecEncTarg(targetMoveBack, 'A');
		motor[motorB] = -1*speed;
  	 motor[motorA] = -1*speed;
		while(abs(nMotorEncoder[motorA]) < targetMoveBack){

			}
			move(0);
			// Ok. Turn
	double distance = getDistanceFromCircle(radiusBetweenWheels, turnTimes);
	double degreesTimesVal;
	degreesTimesVal = degreeTimes(distance, radiusWheel /*or float*/);
	double degrees = 360 * degreesTimesVal;
	short degreeTarget = (short)ceil(degrees);
	resetEncAndSpecEncTarg(degreeTarget, 'B');
  motor[motorB] = -1*speed;
  while (abs(nMotorEncoder[motorB]) < degreeTarget){
  	// continue
  	}
  	motor[motorB] = 0;
  	// is in the right position. Now move backwards.
  	// first degree of distance
  	double degreeTimesVal2 = degreeTimes(20, radiusWheel);
	double degrees2 = 360 * degreeTimesVal2;
	short degreeTarget2 = (short)ceil(degrees2);
	// 2nd degree forr the distance. How far the robot was from the park place when looking
	double distanceFromEdge = kScale/sqrt(sensorValFromEdge)-kError;
	short TargetFromParkPlace = abs(getTargetFromDistance(distanceFromEdge, radiusWheel));
	short totalInparkeerTarget =  degreeTarget2 + TargetFromParkPlace;
	resetEncAndSpecEncTarg(totalInparkeerTarget, 'A');
	char negSpeed = -1*speed;
  	 motor[motorB] = -1*speed;// y uno work with move(-1*speed) :s??
  	 motor[motorA] = -1*speed;
  	 eraseDisplay();
  	while(abs(nMotorEncoder[motorA]) < totalInparkeerTarget){
  		nxtDisplayTextLine(1, "Degree2: %d", degreeTarget2);
  		nxtDisplayTextLine(2, "TargetFPP %d", TargetFromParkPlace);
  		//continue
  		}
  		move(0);
  		double fileTurnDistance = getDistanceFromCircle(radiusBetweenWheels, turnTimes);
  		double fileTurnDegreeTimesVal = degreeTimes(distance, radiusWheel /*or float*/);
  		double fileDegrees = 360 * fileTurnDegreeTimesVal;
  		short fileDegreeTarget = (short)ceil(fileDegrees);
  		resetEncAndSpecEncTarg(fileDegreeTarget, 'A');
  		motor[motorA] = -1*speed;
  		while (abs(nMotorEncoder[motorA]) < degreeTarget){
  			// continue
  		}
  		motor[motorA] = 0;
	}

/*
	automatic can be one of the following values: ['Y', 'N']
*/
void prioToInparkeren(char automatic, short maxSpeed, char speed, double radiusWheel, double radiusBetweenWheels, double turnTimes, int sensorValFromEdge){
	switch (automatic){
	case 'Y':
	eraseDisplay();
	nxtDisplayTextLine(1, "Y");
		// zet de auto in de juist positie om te parkeren.
		/* Psuedo code:
			Rij naar voren zodat de achterkant van de auto op de plek staat waar eerst de sensor stond. Maak dan een
			draaibeweging rond de as van een van de wielen (afhankelijk ofje met neus in of uit wilt parkeren).
			beweeg dan in de juiste richting (vooruit of achteruit) om de auto in het gat te krijgen.
		*/

		park(maxSpeed, speed, radiusWheel, radiusBetweenWheels, turnTimes, sensorValFromEdge);
		break;
	case 'N':
		eraseDisplay();
	nxtDisplayTextLine(1, "N");
		// met sensorgebruik inparkeren.
		break;
	}
}
