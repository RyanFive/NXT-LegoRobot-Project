#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Sensor, S1,     HTANG,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "inparkeren.h"
#include "rotSpeedTest.h"
#include "drivers/hitechnic-angle.h"
#include "motors.h"
#include "Omkeren_bovenaan_de_helling.h"
#include "constanteSnelheid.h"

char move = 'Y'; // this char will be either 'Y' or 'N'. Due to this variable this program has a clear end.

task HTANGActivity(){
		isEdge();
	}

task main(){
	startTask(HTANGActivity);
	moveWithConstantSpeed(30, 60, 1);
	// call omkeren met steken.
	//omkerenMetSteken('A', 1000, 100, 45, 1000); // fine values.
}

//keerhandling
void isEdge(){
	int searchVal = HTEOPDreadRaw(HTEOPD);
	findEdge(searchVal);
	// the following is fiine right? once it's out of the loop from findEdge and the edge is found it stopped moving and won't move again right or should I add a global var to be sure?
	omkerenMetSteken('A', 1000, 100, 45, 1000); // these vals might need some more tweaking.
	}

void findEdge(int searchVal){
	while (true){ // 'natte vinger' bounderies, find solid ones.
		nxtDisplayTextLine(3, "sensor %d", HTEOPDreadRaw(HTEOPD));
		nxtDisplayTextLine(2, "seachval %d", searchVal);//-------------------------------------------------------------------- the wait on the next line is important
		wait1Msec(5); // this was originally 10 ms but during this time other tasks get the time to work. meaning that if there was a constant moving task in an infinte while loop that one will work during this time. So there is no need for another wait after this if right? even though that might be preferable since this program worked with a wait here without the other task.
		// in the multithread does the above line say that this thing will be done twice before the other with constant speed since that one has a 10ms second wait.
		if(!(HTEOPDreadRaw(HTEOPD) > (searchVal - 50))){
			break;
			}
		//move(speed); // keep looking until you find an empty spot
	}
	// edge found, now stop moving.
	move(0);
	move = 'N'; // variable to be sure..
	// cool now turn keke but that's beyond the scope of this function ^^
}

// constante speed
	void adjustMovePower(char adjustment){
	motor[motorA] = motor[motorA] + adjustment;
	motor[motorB] = motor[motorB] + adjustment;
	}

void adjustMovePowerDown(char adjustment){
	motor[motorA] = motor[motorA] - adjustment;
	motor[motorB] = motor[motorB] - adjustment;
	}
	void moveWithConstantSpeed(char speed, int rpm, char adjustment){
	move(speed);
	eraseDisplay();
		for(char i = 0; i < 7; i++){
	nxtDisplayTextLine(i, "RPM: %7d", abs(HTANGreadRPM(HTANG)));
	wait10Msec(3);
	}
	regulateSpeed(rpm, adjustment);
	}

void regulateSpeed(int rpm, char adjustment){
	eraseDisplay();
	while(true){
		if(move == 'N'){ // just to be sure
			break;
			}
		short currentRPM = abs(HTANGreadRPM(HTANG));
		nxtDisplayTextLine(1, "current RPM: %d", currentRPM);
		nxtDisplayTextLine(2, "motopowa: %d", motor[motorA]);
		wait10Msec(10); //----------------------------------------------------------------------------------------- this wait is important

		if(currentRPM > rpm){ // is a boundary of rpm + 1 not better?
			adjustMovePowerDown(adjustment);
			continue;
			} else if (currentRPM < rpm) {
			 adjustMovePower(adjustment);
			continue;
			}
		}
	}

//---------------------------------------------------------- Rotation speed
/**
Set the 0 point to the current angle
HTANGresetAngle(HTANG);
*/

/**
Reset the total accumulated angle to 0
HTANGresetAccumulatedAngle(HTANG);
*/
short getTargetFromDistance(double distance, double radius){
	double degreeTimesVal = degreeTimes(distance, radius);
	double degrees = 360 * degreeTimesVal;
	short degreeTarget = (short)ceil(degrees);
	return degreeTarget;
	}

void readAndDisplayAngle(){ // there's also another function.

		nxtDisplayTextLine(2, "Ang: %7d deg", HTANGreadAngle(HTANG));
		nxtDisplayTextLine(3, "Tot: %7d deg", HTANGreadAccumulatedAngle(HTANG));
		nxtDisplayTextLine(4, "RPM: %7d", HTANGreadRPM(HTANG));

}

void readAndDisplayAngleWhilstMovingReg(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	regMove(speed); // need target or time or while for infite?
	while (true){
		readAndDisplayAngle();
	}
}

void readAndDisplayAngleWhilstMoving(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	move(speed);
	while (true){
		readAndDisplayAngle();
	}
}

// ---------------------------------------------------------- Motors

/*
-- Broken
Let toggle only be 1 or 0
*/
void setPIDSpeedControl(char toggle){
	switch (toggle){
	case 1:
		nPidUpdateInterval = 20; // also set interval of update
		nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
		break;
	case 0:
		nMotorPIDSpeedCtrl[motorA] = mtrNoReg;
		nMotorPIDSpeedCtrl[motorB] = mtrNoReg;
		break;
	}
}

void setMaxSpeed(int maxSpeed){
	//  if you want to achieve consistent speeds across battery level you must either not specify speeds above the 75% level or reduce the maximum speed level.
	nMaxRegulatedSpeedNxt = maxSpeed;
}

/**
broken
*/
void rawMove(char speed){
	setPIDSpeedControl(0); // problem is prob here.
	move(speed);
}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

/**
broken, Get this one working though.
*/
void regMove(char speed){
	//setPIDSpeedControl(1);
	//like this?
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg; // is this rigth?
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	move(100);
}

void resetEncAndSpecEncTarg(short target, char motorChar){
	switch (motorChar){
	case 'A':
		nMotorEncoder[motorA] = 0;
		nMotorEncoderTarget[motorA] = target;
		break;
	case 'B':
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = target;
		break;
	case 'C':
		nMotorEncoder[motorC] = 0;
		nMotorEncoderTarget[motorC] = target;
		break;
	}
}

// only works for A<->B as of yet
void slaveMotor(char emperor, char slave){
	switch (emperor){
	case 'A':
		if (slave == 'B'){
			nSyncedMotors = synchAB;
			break;
		}
		else {
			break;
		}
	case 'B':
		if (slave == 'A'){
			nSyncedMotors = synchBA;
			break;
		}
		else{
			break;
		}
	}
}
/*
	For this function to work right we have to find the right proportion between nMotorEncoderTarget and syncedTurnRatio. We can also use time for the (then) duration that the motors are running.
	syncedTurnToken is 0 or 1, 0 means - and 1 means +.
*/
void omkerenMetSteken(char initialSlave, short maxSpeed, char speed, char syncedTurnRatio, short target){
	setMaxSpeed(maxSpeed);
	char emperor;
	if (initialSlave == 'B'){
		emperor = 'A';
		slaveMotor('A', 'B');
	}
	else if (initialSlave == 'A'){
		emperor = 'B';
		slaveMotor('B', 'A');
	}

	nSyncedTurnRatio = syncedTurnRatio; // will this work? otherwise set the value manually here. Datatype? -> num

	resetEncAndSpecEncTarg(target, emperor);

	switch (emperor){
	case 'A':
		motor[motorA] = -1 * speed;

		while (abs(nMotorEncoder[motorA]) < target){
			nxtDisplayTextLine(2, "%d", nMotorEncoder[motorA]);
		}
		break;
	case 'B':
		motor[motorB] = -1 * speed; // will this work? otherwise create another argument for this value.
		while (abs(nMotorEncoder[motorB]) < target){
			nxtDisplayTextLine(3, "%d", nMotorEncoder[motorB]);
		}
		break;
	}

	// second part
	if (initialSlave == 'B'){
		emperor = 'B'; // overwrite, works?
		slaveMotor('B', 'A');
	}
	else if (initialSlave == 'A'){
		emperor = 'A';
		slaveMotor('A', 'B');
	}

	// reset again.
 	nSyncedTurnRatio = syncedTurnRatio;

	resetEncAndSpecEncTarg(target, emperor);

	switch (emperor){
	case 'A':
		motor[motorA] = speed;
		while (nMotorEncoder[motorA] < target){
		}
		break;
	case 'B':
		motor[motorB] = speed; // will this work? otherwise create another argument for this value.
		while (nMotorEncoder[motorB] < target){
		}
		break;
	}
	nSyncedMotors = synchNone; // for future code.
}
