#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Sensor, S1,     HTANG,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "constanteSnelheid.h"
#include "rotSpeedTest.h"
#include "drivers/hitechnic-angle.h"
#include "motors.h"
#include "Versnelling_bepalen.h"

int sensorWaardeVanSenorRyan;
task ryan() {
	eraseDisplay();
		while(true){
			// dus alleen alles in de while loop wordt gedaan tijdens de wait van de andere functie.
			nxtDisplayTextLine(7,"...");
			wait10Msec(1); // bij nog een taak scheduler inbouwen.
			}
}

task main()
{
	//startTask(ryan);
	moveWithConstantSpeed(30, 60, 1);
}

void moveWithConstantSpeed(char speed, int rpm, char adjustment){
	move(speed);
	eraseDisplay();
		for(char i = 0; i < 7; i++){
	nxtDisplayTextLine(i, "RPM: %7d", abs(HTANGreadRPM(HTANG)));
	wait10Msec(3);
	}
	regulateSpeed(rpm, adjustment);
	}

void regulateSpeed(int rpm, char adjustment){
	eraseDisplay();
	while(true){
		short currentRPM = abs(HTANGreadRPM(HTANG));
		nxtDisplayTextLine(1, "current RPM: %d", currentRPM);
		nxtDisplayTextLine(2, "motopowa: %d", motor[motorA]);
		wait10Msec(10);

		if(currentRPM > rpm){ // is a boundary of rpm + 1 not better?
			adjustMovePowerDown(adjustment);
			continue;
			} else if (currentRPM < rpm) {
			 adjustMovePower(adjustment);
			continue;
			}
		}
	}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

	// should work for both negative and positve values.
void adjustMovePower(char adjustment){
	motor[motorA] = motor[motorA] + adjustment;
	motor[motorB] = motor[motorB] + adjustment;
	}

void adjustMovePowerDown(char adjustment){
	motor[motorA] = motor[motorA] - adjustment;
	motor[motorB] = motor[motorB] - adjustment;
	}
