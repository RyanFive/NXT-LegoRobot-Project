#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Sensor, S1,     HTANG,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rotSpeedTest.h"
#include "drivers/hitechnic-angle.h"
#include "motors.h"
#include "Versnelling_bepalen.h"
task main(){
	enlightenSpeedDifferences(750, 1);
}
// old friends
void setMaxSpeed(int maxSpeed){
	//  if you want to achieve consistent speeds across battery level you must either not specify speeds above the 75% level or reduce the maximum speed level.
	nMaxRegulatedSpeedNxt = maxSpeed;
}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

void resetEncAndSpecEncTarg(short target, char motorChar){
	switch (motorChar){
	case 'A':
		nMotorEncoder[motorA] = 0;
		nMotorEncoderTarget[motorA] = target;
		break;
	case 'B':
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = target;
		break;
	case 'C':
		nMotorEncoder[motorC] = 0;
		nMotorEncoderTarget[motorC] = target;
		break;
	}
}

void slaveMotor(char emperor, char slave){
	switch (emperor){
	case 'A':
		if (slave == 'B'){
			nSyncedMotors = synchAB;
			break;
		}
		else {
			break;
		}
	case 'B':
		if (slave == 'A'){
			nSyncedMotors = synchBA;
			break;
		}
		else{
			break;
		}
	}
}

// specific for this one.
void readAndDisplayAngle(){

		nxtDisplayTextLine(2, "Ang: %7d deg", HTANGreadAngle(HTANG));
		nxtDisplayTextLine(3, "Tot: %7d deg", HTANGreadAccumulatedAngle(HTANG));
		nxtDisplayTextLine(4, "RPM: %7d", HTANGreadRPM(HTANG));

}

void readAndDisplayAngleWhilstMovingReg(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	regMove(speed); // need target or time or while for infite?
	while (true){
		readAndDisplayAngle();
	}
}

void readAndDisplayAngleWhilstMoving(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	move(speed);
	while (true){
		readAndDisplayAngle();
	}
}

// there are some nasty values for motorPowerDiff such as 9, but this works fine for values that have a natural number multiple that results to 100.
void enlightenSpeedDifferences(int maxSpeed, char moterPowerDiff){
	setMaxSpeed(maxSpeed);
	for(char i = 0; i < 100; i + moterPowerDiff){
		eraseDisplay();
		while(true){
		move(i);
		int iRead = HTANGreadRPM(HTANG); // read rot/min for speed of i
		// since it's sync we don't need to give it time here right? (by wait or moterenc)
		//wait1Msec(10); // more than enough. If it's necessary then here's what's needed
		move(0);
		nxtDisplayTextLine(2, "RPM read i: %d", iRead); // or %7d?

		// 2nd read
		move(i+moterPowerDiff);
		int iPlusPlusRead = HTANGreadRPM(HTANG);
		// same concern as above
		//wait1Msec(10);
		move(0);
		nxtDisplayTextLine(3, "RPM read i++: %d", iPlusPlusRead);

		// difference shown
		int rpmDifference = iPlusPlusRead - iRead;
		nxtDisplayTextLine(3, "RPM difference: %d", rpmDifference);

		// iterate when the user presses the orange button.
		// does ik work like this though?? If it doesn't and you can't find another way to do it like that then remove the top while loop and but one around this if statement.
		// OR create a for loop that loops through the above x times before chilling in the infinite while loop that wraps around the if statement below.

			if(nNxtButtonPressed == 3){
				break;
				}
		}
		}
}

// mode is C for continual and B for batch
void enlightenExteriorSpeedDifferences(char speed, int maxSpeed, char mode){
	setMaxSpeed(maxSpeed);
	// the 'helling' is of a certain angle teta so the component of gravity is the same  right?
	switch(mode){
		case 'C':
		continualReading(speed);
		break;
		case 'B':
		batchReading(speed);
		break;
		}
	}

void continualReading(char speed){
	move(speed);
	while(true){
	nxtDisplayTextLine(2, "RPM: %d", HTANGreadRPM(HTANG)); // or %7d?
	if(nNxtButtonPressed == 3){
				break;
				}
	}
}

void batchReading(char speed){
	// 7 displaylines
	move(speed); // k moving up or down a hill
	wait1Msec(10); // ready? then go.

	eraseDisplay();

	int readOne = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read One: %d", readOne); // or %7d?
	wait1Msec(10);

	int readTwo = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read Two: %d", readTwo); // or %7d?
	wait1Msec(10);

	int readThree = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read Three: %d", readThree); // or %7d?
	wait1Msec(10);

	int readFour = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read Four: %d", readFour); // or %7d?
	wait1Msec(10);

	int readFive = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read Five: %d", readFive); // or %7d?
	wait1Msec(10);

	int readSix = HTANGreadRPM(HTANG);
	nxtDisplayTextLine(0, "RPM read Six: %d", readSix); // or %7d?
	wait1Msec(10);

	int average = (readOne + readTwo + readThree + readFour + readFive + readSix)/6;
	nxtDisplayTextLine(0, "RPM average: %d", average); // or %7d?
	}
