#pragma config(Motor,  motorA,          motorOne,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorTwo,      tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Sensor, S1,     HTANG,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rotSpeedTest.h"
#include "drivers/hitechnic-angle.h"
#include "motors.h"
task main(){
	// call omkeren met steken.
	omkerenMetSteken('A', 1000, 100, 45, 1000); // fine values.
}

//---------------------------------------------------------- Rotation speed
/**
Set the 0 point to the current angle
HTANGresetAngle(HTANG);
*/

/**
Reset the total accumulated angle to 0
HTANGresetAccumulatedAngle(HTANG);
*/

void readAndDisplayAngle(){ // there's also another function.

		nxtDisplayTextLine(2, "Ang: %7d deg", HTANGreadAngle(HTANG));
		nxtDisplayTextLine(3, "Tot: %7d deg", HTANGreadAccumulatedAngle(HTANG));
		nxtDisplayTextLine(4, "RPM: %7d", HTANGreadRPM(HTANG));

}

void readAndDisplayAngleWhilstMovingReg(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	regMove(speed); // need target or time or while for infite?
	while (true){
		readAndDisplayAngle();
	}
}

void readAndDisplayAngleWhilstMoving(char speed, int maxSpeed){
	setMaxSpeed(maxSpeed);
	move(speed);
	while (true){
		readAndDisplayAngle();
	}
}

// ---------------------------------------------------------- Motors

/*
-- Broken
Let toggle only be 1 or 0
*/
void setPIDSpeedControl(char toggle){
	switch (toggle){
	case 1:
		nPidUpdateInterval = 20; // also set interval of update
		nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
		break;
	case 0:
		nMotorPIDSpeedCtrl[motorA] = mtrNoReg;
		nMotorPIDSpeedCtrl[motorB] = mtrNoReg;
		break;
	}
}

void setMaxSpeed(int maxSpeed){
	//  if you want to achieve consistent speeds across battery level you must either not specify speeds above the 75% level or reduce the maximum speed level.
	nMaxRegulatedSpeedNxt = maxSpeed;
}

/**
broken
*/
void rawMove(char speed){
	setPIDSpeedControl(0); // problem is prob here.
	move(speed);
}

void move(char speed){
	motor[motorA] = speed;
	motor[motorB] = speed;
}

/**
broken, Get this one working though.
*/
void regMove(char speed){
	//setPIDSpeedControl(1);
	//like this?
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg; // is this rigth?
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	move(100);
}

void resetEncAndSpecEncTarg(short target, char motorChar){
	switch (motorChar){
	case 'A':
		nMotorEncoder[motorA] = 0;
		nMotorEncoderTarget[motorA] = target;
		break;
	case 'B':
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = target;
		break;
	case 'C':
		nMotorEncoder[motorC] = 0;
		nMotorEncoderTarget[motorC] = target;
		break;
	}
}

// only works for A<->B as of yet
void slaveMotor(char emperor, char slave){
	switch (emperor){
	case 'A':
		if (slave == 'B'){
			nSyncedMotors = synchAB;
			break;
		}
		else {
			break;
		}
	case 'B':
		if (slave == 'A'){
			nSyncedMotors = synchBA;
			break;
		}
		else{
			break;
		}
	}
}
/*
	For this function to work right we have to find the right proportion between nMotorEncoderTarget and syncedTurnRatio. We can also use time for the (then) duration that the motors are running.
	syncedTurnToken is 0 or 1, 0 means - and 1 means +.
*/
void omkerenMetSteken(char initialSlave, short maxSpeed, char speed, char syncedTurnRatio, short target){
	setMaxSpeed(maxSpeed);
	char emperor;
	if (initialSlave == 'B'){
		emperor = 'A';
		slaveMotor('A', 'B');
	}
	else if (initialSlave == 'A'){
		emperor = 'B';
		slaveMotor('B', 'A');
	}

	nSyncedTurnRatio = syncedTurnRatio; // will this work? otherwise set the value manually here. Datatype? -> num

	resetEncAndSpecEncTarg(target, emperor);

	switch (emperor){
	case 'A':
		motor[motorA] = -1 * speed;

		while (abs(nMotorEncoder[motorA]) < target){
			nxtDisplayTextLine(2, "%d", nMotorEncoder[motorA]);
		}
		break;
	case 'B':
		motor[motorB] = -1 * speed; // will this work? otherwise create another argument for this value.
		while (abs(nMotorEncoder[motorB]) < target){
			nxtDisplayTextLine(3, "%d", nMotorEncoder[motorB]);
		}
		break;
	}

	// second part
	if (initialSlave == 'B'){
		emperor = 'B'; // overwrite, works?
		slaveMotor('B', 'A');
	}
	else if (initialSlave == 'A'){
		emperor = 'A';
		slaveMotor('A', 'B');
	}

	// reset again.
 	nSyncedTurnRatio = syncedTurnRatio;

	resetEncAndSpecEncTarg(target, emperor);

	switch (emperor){
	case 'A':
		motor[motorA] = speed;
		while (nMotorEncoder[motorA] < target){
		}
		break;
	case 'B':
		motor[motorB] = speed; // will this work? otherwise create another argument for this value.
		while (nMotorEncoder[motorB] < target){
		}
		break;
	}
	nSyncedMotors = synchNone; // for future code.
}
